<html>
	<head>
		<link rel="stylesheet" type="text/css" href="minireset.css"/>
		<link rel="shortcut icon" type="image/png" href="images/reactor.png"/>
		<style type="text/css">
			html, body{
				height: 100%;
				overflow: hidden;
			}
			body {
				color: rgb(220, 220, 220);
				background-color: #061319;
			}

			#canvas{
				width: 100%;
				height: 100%;
				cursor: crosshair;
				display: none;
			}
			#menus{
				border: 1px solid black;
				height: 100%;
				min-width: 1024px;
			}
			#menuBg{
				z-index: -1;
				width: 100%;
				min-width: 1024px;
				height: 100%;
				position: absolute;
			}
			.menu{
				margin-left: 15%;
				margin-right: 20%;
				margin-top: 6%;
			}
			.show{
				display: block;
			}
			.hide{
				display: none;
			}
			.mainTitle{
				font-size: 500%;
				font-family: "impact";
			}
			#overlayMenu{
				display: none;
				background-color: rgba(0, 0, 0, 0.75);
				z-index: 10;
				position: absolute;
				width: 100%;
				height: 100%;
				align-items: center;
			}
			#pauseMenu, #gameOverScreen{
				border: 1px solid #537b80;
				background-color: rgba(54, 178, 262, 0.25);
				z-index: 11;
				margin-left: auto;
				margin-right: auto;
				width: 800;
				padding: 32px;
				margin-top: 50px;
			}
			.timeTable tr td {
				padding-right: 8px;
			}
			.ctr{
				text-align: center;
			}
			.ctrMargin{
				margin-left: auto;
				margin-right: auto;
			}
			.right{
				text-align: right;
			}
			.pauseMenuTitle{
				text-align: center;
 				margin-bottom: 32px;
			}
			.menuTitle{
				font-size: 500%;
				font-family: "impact";
				color: rgb(6, 17, 22);
				text-shadow:
					-1px -1px 0 #acbccc,
					1px -1px 0 #acbccc,
					-1px 1px 0 #acbccc,
					1px 1px 0 #acbccc;
			}
			.menuText{
				font-size: 150%;
				font-family: "courier";
			}
			.menuText p{
				padding-bottom: 20px;
				color: rgb(220, 220, 220);
			}
			.menuButton, .bigMenuButton{
				width: 235px;
				font-size: 200%;
				font-family: "Arial";
				border-radius: 10px;
				color: rgb(220, 220, 220);
				background-color: rgba(0, 0, 0, 0);
				margin-top: 2px;
				margin-bottom: 2px;
				border: 1px solid rgb(220, 220, 220);
			}
			.menuButton:hover, .bigMenuButton:hover{
				margin-top: 1px;
				margin-bottom: 1px;
				border: 2px solid white;
			}
			.levelButton{
				margin-left: 2px;
				margin-right: 2px;
				width: 60px;
				text-align: center;
			}
			.levelDisable{
				background-color: rgba(105,105,105,0.4);
				color: rgb(150,150,150,0.6);
				border: 1px solid rgb(150,150,150,0.6);
			}
			.levelDisable:hover{
				margin-top: 2px;
				margin-bottom: 2px;
				border: 1px solid rgb(150,150,150,0.6);
			}
			.bigMenuButton{
				font-size: 300%;
			}
			#playButton{
				width: 100px;
	   			height: 50px;
			}
			.spacer {
				margin: 0px;
				padding: 0px;
				height: 24px;
			}
			.spacer2x {
				margin: 0px;
				padding: 0px;
				height: 48px;
			}
			#demoNote {
				position: absolute;
				top: 0px;
				width:100%;
			}
			#demoNote div {
				background-color: black;
				color: gray;
				float: right;
			}
			#editorPanel{
				display: none;
				background-color: white;
				padding: 5px;
				color: black;
				z-index: 100;
				position: absolute;
				top: 0px;
				left: 0px;
			}
			@media (max-width: 1336px) {
				.menuTitle {
					font-size: 300%;
				}
				.menuText{
					font-size: 18px;
				}
				.menuButton{
					font-size: 150%;
				}
			}
			@media (min-width: 1131px) and (max-width: 1336px) {
				.menuTitle {
					font-size: 400%;
				}
				.menuText{
					font-size: 20px;
				}
				.menuButton{
					font-size: 175%;
				}
			}
		</style>
		<title>Reactor Rescue</title>
		<script src="jquery-3.3.1.js" charset="utf-8"></script>
		<script src="levels.js" charset="utf-8"></script>
		<script src="debug.js" charset="utf-8"></script>
		<script src="editor.js" charset="utf-8"></script>
		<script src="howler2.js" charset="utf-8"></script>
		<script src="JSONSafeStringify.js" charset="utf-8"></script>
		<script>
			let FPS = 60;
			

			let Rules = {
				speedMod: 3,
				blowRange: 200,
				blowForce: 100,
				friction: 1,
				minSpeed: 1,
				playerSpeed: 500,
				runningGameSpeed: 0.5,
				gameSpeed: 0,
				defaultBoundaryMargin: 250,
				minBoundaryMargin: 15,
				timeFail: 9999,
				volume: 0.1,
				musicVolume: 0.03,
				isDemo: window.location.href.indexOf('demo')>=0,
				isTest: false, //window.location.href.indexOf('localhost')>=0,
				isEditing: window.location.href.indexOf('edit')>=0,
				startLevel: 32,
				isCinematic: false,
				showLevelBuilder: false,
				boundaryShowRange: 100,
				demoLevelLimit: 99,
				zOrders: {boundary: -2, text: -1, particle: 0, blower: 1, reactor: 2, bullet: 3, mine: 4, destructible: 5, turret: 6, barricade: 7, bouncer: 7, gate: 8, checkPoint: 8, receptical: 8}
			};

			let canvasWidth;
			let canvasHeight;
			let handleView;
			let handleInterval;

			let respawnCoords = null;

			let storedTime = 0;

 			let debug = new Debug;

			let Records = {
				you: [],
				best: [],
			};

			function timeReadable(elapsedTime) {
				let s = ''+Math.floor(elapsedTime*10)/10;
				if( s.indexOf('.')<0 ) {
					s += '.0';
				}
				return s;
			}

			function squareToCircleCollision(pieceX, pieceY, piece2X, piece2Y, pieceHitBoxRadius, piece2HitBoxSize){
				let sx = piece2X-piece2HitBoxSize/2;
				let sy = piece2Y-piece2HitBoxSize/2;
				let ex = piece2X+piece2HitBoxSize/2;
				let ey = piece2Y+piece2HitBoxSize/2;

				//Cardinal Directions
				if(pieceX+pieceHitBoxRadius > sx && pieceX-pieceHitBoxRadius < ex && pieceY > sy && pieceY < ey){
					return true;
				}
				if(pieceY+pieceHitBoxRadius > sy && pieceY-pieceHitBoxRadius < ey && pieceX > sx && pieceX < ex){
					return true;
				}

				//Corners
				if(pieceX <= sx && pieceY <= sy && calcDist(pieceX, pieceY, sx, sy) < pieceHitBoxRadius){
					return true;
				}
				if(pieceX >= ex && pieceY <= sy && calcDist(pieceX, pieceY, ex, sy) < pieceHitBoxRadius){
					return true;
				}
				if(pieceX <= sx && pieceY >= ey && calcDist(pieceX, pieceY, sx, ey) < pieceHitBoxRadius){
					return true;
				}
				if(pieceX >= ex && pieceY >= ey && calcDist(pieceX, pieceY, ex, ey) < pieceHitBoxRadius){
					return true;
				}
			}

			function SoundBank(){
				var list = [];
				var handle = {};
				this.load = function(name, src, volume) {
					list[name] = new Howl({
						src: [src],
						volume: (volume || 1.0)*Rules.volume
					});
				};
				this.loadLoop = function(name, params) {
					list[name] = new Howl(params);
				};
				this.play = function(name) {
					handle[name] = list[name].play();
					return handle[name];
				};
				this.playLoop = function(name) {
					handle[name] = list[name].play("main");
					return handle[name];
				};
				this.stop = function(name) {
					if( handle[name] ) {
						list[name].stop(handle[name]);
					}
				};
				this.stopAll = function() {
					for( var name in list ) {
						this.stop(name);
					}
				}
				return this;
			}

			let soundBank = new SoundBank;
			$(document).on('click',".menuButton", function(){
				soundBank.play("click");
			});
			function degToRad(deg){
				return (deg/180*Math.PI);
			}
			function radToDeg(rad){
				return (rad/Math.PI*180)+180;
			}
			/*
			function normalizeRads(rad){
				while(Math.abs(rad) > Math.PI){
					if(rad > 0){
						rad -= Math.PI*2;
					}else{
						rad += Math.PI*2;
					}
				}
				return rad;
			}
			*/
			function randInt(max) {
				return Math.floor(Math.random()*max);
			}

			function calcDist(x1, y1, x2, y2){
				let dx = (x1-x2);
				let dy = (y1-y2);
				return Math.abs(Math.sqrt(Math.pow(dx, 2)+Math.pow(dy, 2)))
			}
			function calcAngle(x1, y1, x2, y2){
				let dx = (x2-x1);
				let dy = (y2-y1);
				let rad = Math.atan2(dy,dx)
				return rad;
			}
			function isWithinArc(sourceRad, targetRad, arc){
				let a0 = sourceRad;
				let a1 = sourceRad - Math.PI*2;
				let a2 = sourceRad + Math.PI*2;
				let min = targetRad - arc;
				let max = targetRad + arc;

				if(
					(a0 >= min && a0 <= max) ||
					(a1 >= min && a1 <= max) ||
					(a2 >= min && a2 <= max)
				){
					return true;
				}
				return false;
			}


			var Internet = function() {
				var attempt = {};
				var counter = 0;

				function isEmpty(obj) {
				    for(var prop in obj) {
				        if(obj.hasOwnProperty(prop))
				            return false;
				    }
				    return true;
				}
				
				this.retry = function() {
					for( var handle in attempt ) {
						attempt[handle]();
					}
				}
				function clear(handle) {
					delete attempt[handle];
					if( isEmpty(attempt) ) {
						$('#internetDown').hide();
					}
				}
				function error(j, textStatus, errorThrown) {
					if( j.status == 0 ) {
						$('#internetDown').show();
					}
					else {
						alert(textStatus, errorThrown);
					}
				}
				this.ajax = function(_spec,callback) {
					var handle = counter++;
					var spec = $.extend(true,{},_spec);
					spec.timeout = 10*1000;
					spec.success = function(data) {
						clear(handle);
						callback(data);
					}
					spec.error = error;
					attempt[handle] = function() {
						$.ajax(spec);
					}
					attempt[handle]();
					return handle;
				}

				return this;
			}

			let internet = new Internet();
			let LevelList = MakeLevelList();
 			let level;
 			let levelPlan;
 			let demoProgress = [];
 			let demoRecords = [];
 			for( let i=0 ; i<Rules.demoLevelLimit ; ++i ) {
 				demoProgress[i] = { time: 3*60 };
 				demoRecords[i]  = { time: 999, userName: 'demo' };
 			}

			let testProgress = [];
			let testRecords = [];
			for( let i=0 ; i<LevelList.length ; ++i ) {
				testProgress[i] = { time: 3*60 };
				testRecords[i]  = { time: 999, userName: 'tester' };
			}

			let progressGet = function(callback) {

				function establishPersonalRecords(progress) {
					var i = 0;
					while(progress[i] && progress[i].time < Rules.timeFail && i < LevelList.length-1){
						Records.you[i] = Records.you[i] || {};
						Records.you[i].time = progress[i].time || Rules.timeFail;
						i ++;
					}
				}

				function processData(progress){
					establishPersonalRecords(progress);
					callback(progress);
				}

				if( Rules.isDemo ) {
					return setTimeout( ()=>processData(demoProgress), 1 );
				}
				if( Rules.isTest ) {
					return setTimeout( ()=>processData(testProgress), 1 );
				}
				internet.ajax({
					url: '/progressRr',
					method: 'GET',
					contentType:"application/json; charset=utf-8",
					data: {},
				}, processData
				);

			}

			let progressSave = function(levelNumber,time,callback) {
				if( Rules.isDemo ) {
					setTimeout( function() {
						demoProgress[levelNumber] = { time: time };
						if( time < demoRecords[levelNumber].time ) {
							demoRecords[levelNumber].time = time;
							demoRecords[levelNumber].userName = 'demo';
						}
						callback( { result: 'success' } );
					}, 1 );
					return;
				}
				if( Rules.isTest ) {
					setTimeout( function() {
						testProgress[levelNumber] = { time: time };
						if( time < testRecords[levelNumber].time ) {
							testRecords[levelNumber].time = time;
							testRecords[levelNumber].userName = 'test';
						}
						callback( { result: 'success' } );
					}, 1 );
					return;
				}

				internet.ajax({
					url: '/progressRr',
					method: 'POST',
					contentType:"application/json; charset=utf-8",
					data: JSON.stringify({
					    level: levelNumber,
					    time: time
					})
				}, callback);
			}

			let recordsGet = function(callback) {

				function establishBestRecords(records) {
					for( let i=0 ; i<LevelList.length ; ++i ) {
						Records.best[i] = records[i] || {time: Rules.timeFail};
						if( !Records.best[i].time ) {
							Records.best[i].time = Rules.timeFail;
						}
					}
					callback();
				}

				if( Rules.isDemo ) {
					return setTimeout( ()=>establishBestRecords(demoRecords), 1 );
				}
				if( Rules.isTest ) {
					return setTimeout( ()=>establishBestRecords(testRecords), 1 );
				}
				internet.ajax({
					url: '/recordsRr',
					method: 'GET',
					contentType:"application/json; charset=utf-8",
					data: {},
				}, establishBestRecords );
			}


			function MakeStars() {
				window.star = [];
				let w = canvasWidth;
				let h = canvasHeight;
				for( let i=0 ; i<150 ; ++i ) {
					let depth = 0.1+Math.random()*0.85;
					window.star[i] = {
						img: Img['star'+randInt(5)],
						x: randInt(w*1.3/depth),
						y: randInt(h*1.3/depth),
						xSpan: (w+randInt(w*0.3)),
						ySpan: (h+randInt(h*0.3)),
						depth: depth
					}
				}
			}
 			class Sim{
 				constructor(){
 					this.elapsedTime = storedTime;
 					this.pieceList = [];

					this.nowPrior = null;
 					this.gameFailLatch = false;

 					this.editor = new Editor(this);

 					this.makePieceListFromSource(levelPlan.pieceSource, levelPlan.boundaryMargin)
 				}
				addPiece(x, y, type, object){
					let newPiece;
					if(type == "blower"){
						newPiece = (new Blower(this, x, y))
					}
					if(type == "reactor"){
						newPiece = (new Reactor(this, x, y))
					}
					if(type == "gate"){
						newPiece = (new Gate(this, x, y))
					}
					if(type == "checkPoint"){
						newPiece = (new CheckPoint(this, x, y))
					}
					if(type == "receptical"){
						newPiece = (new Receptical(this, x, y))
					}
					if(type == "mine"){
						newPiece = (new Mine(this, x, y))
					}
					if(type == "barricade"){
						newPiece = (new Barricade(this, x, y))
					}
					if(type == "bouncer"){
						newPiece = (new Bouncer(this, x, y, object.bounceAmount))
					}
					if(type == "destructible"){
						newPiece = (new Destructible(this, x, y))
					}
					if(type == "turret"){
						newPiece = (new Turret(this, x, y, object.fireDelay, object.bulletSpeed, object.fireType, object.angle, object.angleFixed))
					}
					if(type == "bullet"){
						newPiece = (new Bullet(this, x, y, object.xVel, object.yVel))
					}
					if(type == "phaseBullet"){
						newPiece = (new PhaseBullet(this, x, y, object.xVel, object.yVel))
					}
					if(type == "text"){
						newPiece = (new Text(this, x, y, object.text, object.condition))
					}
					debug.assert(newPiece, "invalid piece type", type)
					return newPiece;
				}
				find(type){
 					return this.pieceList.find((piece)=>piece.type == type);
 				}
 				exists(type){
 					return !!this.find(type);
 				}
 				get blower(){
 					return this.find("blower");
 				}
 				get reactor(){
 					return this.find("reactor");
 				}
 				tick(dt){
 					if(this.editor.active){
 						this.boundary.resize();
 					}
					this.piecesBlown(dt);
					if(this.piecesTouched() == "next level"){
						return "next level"
					}
					this.elapsedTime += dt;
					this.pieceList.forEach(piece => piece.tick(dt))
					for (var i = 0; i < this.pieceList.length; i++){
						if(this.pieceList[i].dead && !this.pieceList[i].warping){
							this.pieceList.splice(i, 1)
						}
					}
				}
				makePieceListFromSource(pieceSource, boundaryMargin){
					console.assert( boundaryMargin !== null && boundaryMargin !== undefined );

					for (let i = 0; i < pieceSource.length; i++) {
 						let object = pieceSource[i];
						this.addPiece(object.x, object.y, object.type, object)
					}

					let reactorLastPosition = [0,0];
					this.boundary = new Boundary(
						this,
						boundaryMargin,
						() => {
							if( this.reactor ) {
								reactorLastPosition = [this.reactor.x, this.reactor.y];
							}
							return reactorLastPosition;
						}
					)
				}
 				piecesBlown(dt){
 					let blower = this.blower;
 					if(!blower){return}
					if(blower.blowing){
						for(let i = 0; i < this.pieceList.length; i++){
							let piece = this.pieceList[i];
							if(!piece.blowable){
								continue;
							}
							let angle = calcAngle(blower.x, blower.y, piece.x, piece.y);
							let blowArc = degToRad(45);
							let dist = calcDist(blower.x, blower.y, piece.x, piece.y);
							if(isWithinArc(blower.angle, angle, blowArc) && dist < Rules.blowRange){
								let velIncrease = (((Rules.blowRange-calcDist(blower.x, blower.y, piece.x, piece.y))*Rules.blowForce)/piece.mass)*dt;
								piece.xVel -= velIncrease*((blower.x - piece.x)/dist)
								piece.yVel -= velIncrease*((blower.y - piece.y)/dist)
							}
						}
					}else{
						console.log()
					}
				}
 				piecesTouched(){
 					let nextLevel = false;
					this.pieceList.forEach(piece => {
						if(piece.dead || !piece.collider){
							return;
						}
						for(let i = 0; i < this.pieceList.length; i++){
							let piece2 = this.pieceList[i];
							if(piece2.dead || !piece2.collider){
								continue;
							}
							if(piece == piece2){
								continue;
							}
							if(piece2.hitBoxRadius){
								if(calcDist(piece.x, piece.y, piece2.x, piece2.y) < (piece.hitBoxRadius+piece2.hitBoxRadius)){
									if(piece.onTouch(piece2.effect) == "next level"){
										nextLevel = true;
									}
								}
							}else{
								if(squareToCircleCollision(piece.x, piece.y, piece2.x, piece2.y, piece.hitBoxRadius, piece2.hitBoxSize)){
									piece.onTouch(piece2.effect)
								}
							}
						}
					})
					if(nextLevel){
						return "next level"
					}
				}
			}

			class Piece{
				constructor(type, sim, x, y, isParticle){
					debug.expect(sim, "object", "sim")
					debug.expectNum(x, "x")
					debug.expectNum(y, "y")
					this.type = type;
					this.sim = sim;
					this.sim.pieceList.push(this);
					this.x = x;
					this.y = y;
					let z;
					if(isParticle){
						this.isParticle = true;
						z = Rules.zOrders.particle;
					}else{
						this.isParticle = false;
						z = Rules.zOrders[this.type];
					}
					debug.expectNum(z, "z")
					this.z = z+Math.random();
					this.xVel = 0;
					this.yVel = 0;
					this.mass = 1;
					this.width;
					this.height;
					this.hitBoxRadius;
					this.effect;
					this.collider = true;
				}
				get xMin() {
					return this.x - (this.hitBoxRadius===undefined ? this.width/2 : this.hitBoxRadius);
				}
				get xMax() {
					return this.x + (this.hitBoxRadius===undefined ? this.width/2 : this.hitBoxRadius);
				}
				get yMin() {
					return this.y - (this.hitBoxRadius===undefined ? this.height/2 : this.hitBoxRadius);
				}
				get yMax() {
					return this.y + (this.hitBoxRadius===undefined ? this.height/2 : this.hitBoxRadius);
				}
				draw(context, camera){
					let pieceSpec = {
						piece: this,
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					context.draw(pieceSpec, Img[this.type], camera)
				}
				onTouch(effect){
					if(effect.type == "damage" && !this.warping ){
						this.health -= effect.amount;
					}
					if(effect.type == "bounce"){
						if(this.xVel !== 0 || this.yVel !== 0){
							let bounced = false;
							if(Math.abs(effect.x - this.x) > Math.abs(effect.y - this.y)){
								if(this.x > effect.x && this.xVel < 0){
									this.xVel *= -effect.amount;
									bounced = true;
								}
								if(this.x < effect.x && this.xVel > 0){
									this.xVel *= -effect.amount;
									bounced = true;
								}
							}else{
								if(this.y > effect.y && this.yVel < 0){
									this.yVel *= -effect.amount;
									bounced = true;
								}
								if(this.y < effect.y && this.yVel > 0){
									this.yVel *= -effect.amount;
									bounced = true;
								}
							}
							if(bounced){soundBank.play("bounce")}
						}
					}
					if(effect.type == "win" && this.type == "reactor" && !this.warping){
						//soundBank.play("warpOut")
						this.x = effect.x;
						this.y = effect.y;
						this.warpPhase = this.warpDuration;
						return "next level";
					}
					if(effect.type == "checkPoint" && this.type == "reactor" && !this.warping){
						if(!respawnCoords || effect.x != respawnCoords.x || effect.y != respawnCoords.y){
							storedTime = this.sim.elapsedTime;
							respawnCoords = {x: effect.x, y: effect.y}
							soundBank.play("checkPoint")
						}
					}
					if(effect.type == "attach" && this.type == "reactor"){
						if(!this.attached){
							soundBank.stop("gameMusic")
							soundBank.playLoop("victoryMusic")
							soundBank.play("woosh")
							soundBank.play("charging")
							setTimeout(()=>{this.sim.boundary.earthIsOn = true; soundBank.play("turnOn")}, 7500)
							setTimeout(()=>this.sim.blower.credits = true, 12500)
						}
						this.x = effect.x;
						this.y = effect.y;
						this.attached = true;
						this.xVel = 0;
						this.yVel = 0;

					}
				}
				applyVelocity(dt){
					let velocity = Math.sqrt(this.xVel*this.xVel+this.yVel*this.yVel);
					if( velocity > Rules.minSpeed ) {
						this.x += this.xVel*dt*Rules.gameSpeed;
						this.y += this.yVel*dt*Rules.gameSpeed;
					}
				}
				applyFriction(dt){
					this.xVel -= (this.xVel*Rules.friction)*dt*Rules.gameSpeed;
					this.yVel -= (this.yVel*Rules.friction)*dt*Rules.gameSpeed;
				}
				particleTick(){}
				tick(dt){
					this.particleTick(dt);
					if(!this.dead){
						if(this.control == "AI"){
							//this.ai(pieceList);
						}
						this.applyVelocity(dt)

						if(this.hasFriction !== false){
							this.applyFriction(dt)
						}

						if( !this.sim.boundary.contains(this.x, this.y, this.width, this.height) && !this.surviveOutOfBounds) {
							this.dead = true;
						}

						if(this.health <= 0 && !this.warping){
							this.dead = true;
						}

						if( this.dead ) {
							if(this.type == "reactor" ){
								soundBank.play("explosionBig");
								let temp = this;
								for( let i=0 ; i<7 ; ++i ) {
									setTimeout( function() {
										let x = temp.x + (Math.random()-0.5) * 80;
										let y = temp.y + (Math.random()-0.5) * 80;
										let scale = 0.5+(Math.random()*2.0);
										new Explosion(temp.sim, x, y, temp.xVel/3, temp.yVel/3, scale);
									}, i*0.3 );
								}
							}
							if(this.type == "destructible"){
								soundBank.play("explosionSmall");
								new ExplosionBlue(this.sim, this.x, this.y, this.xVel/3, this.yVel/3)	
							}
						}
					}
				}
			}

			class Boundary{
				constructor(sim, margin, getPayloadPositionFn){
					this.margin = margin;
					this.getPayloadPositionFn = getPayloadPositionFn;
					debug.expectNum(this.margin, "margin not a number")
					this.sim = sim;
					this.earthIsOn = false;
					debug.assert(this.sim.pieceList.length, "make boundary after pieceList init")
					this.resize()
				}
				setMargin(margin){
					debug.expectNum(margin, "margin not num")
					this.margin = margin;
					this.resize();
				}
				resize(){
					this.top = null;
					this.bottom = null;
					this.left = null;
					this.right = null;
					for (let i = 0; i < this.sim.pieceList.length; i++) {
						let piece = this.sim.pieceList[i];
						let ignorePieceTypes = { text: 1 };
						if( ignorePieceTypes[piece.type] ){
							continue;
						}
						if(this.left === null || piece.xMin < this.left){
							this.left = piece.xMin;
						}
						if(this.right === null || piece.xMax > this.right){
							this.right = piece.xMax;
						}
						if(this.top === null || piece.yMin < this.top){
							this.top = piece.yMin;
						}
						if(this.bottom === null || piece.yMax > this.bottom){
							this.bottom = piece.yMax;
						}
					}
					if(this.top === null){
						this.top = -100;
						this.bottom = 100;
						this.left = -100;
						this.right = 100;
					}
					debug.expectNum(this.margin, "margin")
					this.top -= this.margin;
					this.bottom += this.margin;
					this.left -= this.margin;
					this.right += this.margin;
				}
				get xMin() { return this.left; }
				get xMax() { return this.right; }
				get yMin() { return this.top; }
				get yMax() { return this.bottom; }
				get width() { return this.xMax-this.xMin; }
				get height() { return this.yMax-this.yMin; }
				contains(x, y, width, height) {
					width /= 2;
					height /= 2;

					if(width && height){
						return x-width>=this.xMin && x+width<=this.xMax && y-height>=this.yMin && y+height<=this.yMax;
					}
					return x>=this.xMin && x<=this.xMax && y>=this.yMin && y<=this.yMax;
				}
				clamp(x,y) {
					debug.expectNum(this.top, "top")
					debug.expectNum(this.bottom, "bottom")
					debug.expectNum(this.left, "left")
					debug.expectNum(this.right, "right")
					return [Math.min(Math.max(x,this.xMin),this.xMax),Math.min(Math.max(y,this.yMin),this.yMax)];
				}
				draw(context, camera){

					let alpha;

					if(this.sim.editor.active){
						alpha = 1;
					}else{
						let x;
						let y;
						[x,y] = this.getPayloadPositionFn()
						debug.expectNum(x, "x");
						debug.expectNum(y, "y");
						let xMinDist = Math.abs(x - this.xMin);
						let xMaxDist = Math.abs(x - this.xMax);
						let yMinDist = Math.abs(y - this.yMin);
						let yMaxDist = Math.abs(y - this.yMax);
						alpha = Math.min(xMinDist, xMaxDist, yMinDist, yMaxDist);
						alpha *= -1;
						alpha += Rules.boundaryShowRange;
						alpha /= Rules.boundaryShowRange;
					}

					context.beginPath();
					context.lineWidth="6";
					context.strokeStyle="rgba(255,0,0,"+alpha+")";
					context.rect(this.xMin-(camera.x-canvasWidth/2), this.yMin-(camera.y-canvasHeight/2), this.width, this.height);
					context.stroke();
				}
			}

			class Reactor extends Piece{
				constructor(sim, x, y){
					super("reactor", sim, x, y)
					if(respawnCoords){
						this.x = respawnCoords.x;
						this.y = respawnCoords.y;
					}
					this.mass = 25;
					this.width = 40;
					this.height = 40;
					this.sim = sim;
					this.hitBoxRadius = 20;
					this.blowable = true;
					this.effect = {type: "none"};
					this.health = 10;
					this.warpParticleCount = 0;
					this.warpPhase = 0;
					this.warpDuration = 0.5;
					this.warpingIn = true;
				}
				particleTick(dt){
					if(this.warpPhase <= this.warpDuration){
						if(this.warpingIn){
							this.warpPhase += dt;
						}else{
							this.warpPhase -= dt;
						}
						this.xVel = 0;
						this.yVel = 0;
						if(this.warpPhase < 0.5*this.warpDuration){
							this.warpParticleCount = this.warpPhase*300;
						}else{
							this.warpParticleCount = (this.warpDuration-this.warpPhase)*300/2;
						}
						this.warping = true;
					}else{
						this.warping = false;
						this.warpingIn = false
					}

					if(this.warping){
						for (var i = 0; i < dt*this.warpParticleCount*Rules.gameSpeed; i++) {
							new Trail(this.sim, this.x+((Math.random()-0.5)*40), this.y+((Math.random()-0.5)*40), 0, 0, 0)
						}	
					}
					for (var i = 0; i < dt*10*Rules.gameSpeed; i++) {
						if(Math.random()>0.95){
							new Electricity(this.sim, this.x+((Math.random()-0.5)*20), this.y+((Math.random()-0.5)*20), 0, 0, 0)
						}
					}
				}
				draw(context, camera){
					let pieceSpec = {
						piece: this,
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					if(this.warpPhase > 0.5*this.warpDuration){
						context.draw(pieceSpec, Img[this.type], camera)
					}
				}
			}

			class Gate extends Piece{
				constructor(sim, x, y){
					super("gate", sim, x, y)
					this.width = 150;
					this.height = 150;
					this.hitBoxRadius = 30;
					this.blowable = false;
					this.effect = {type: "win", x: this.x, y: this.y};
				}
				/*particleTick(dt){
					let particleAngleMargin = degToRad(90)
					let particleAngle = this.angle+((Math.random()-0.5)*particleAngleMargin)
					let velocity = 750;
					let xVel = velocity*Math.cos(particleAngle);
					let yVel = velocity*Math.sin(particleAngle);
					new Force(this.sim, this.x, this.y, xVel, yVel, radToDeg(particleAngle)+180)
				}*/
			}
			class CheckPoint extends Piece{
				constructor(sim, x, y){
					super("checkPoint", sim, x, y)
					this.width = 80;
					this.height = 80;
					this.hitBoxRadius = 30;
					this.blowable = false;
					this.effect = {type: "checkPoint", x: this.x, y: this.y};
				}
				get on(){
					if (respawnCoords) {
						if(this.x == respawnCoords.x && this.y == respawnCoords.y){
							return true;
						}
					}
					return false;
				}
				draw(context, camera){
					let pieceSpec = {
						piece: this,
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					let image = (this.on ? Img["checkPointOn"] : Img["checkPointOff"])
					context.draw(pieceSpec, image, camera)

				}
			}
			class Receptical extends Piece{
				constructor(sim, x, y){
					super("receptical", sim, x, y)
					this.width = 170;
					this.height = 170;
					this.hitBoxRadius = 10;
					this.blowable = false;
					this.effect = {type: "attach", x: this.x, y: this.y};
					this.particleCount = 0;
					this.surviveOutOfBounds = true;
				}
				particleTick(dt){
					if(this.sim.reactor){
						if(this.sim.reactor.attached && !this.sim.boundary.earthIsOn){
							this.particleCount += 0.5;
						}
					}
					for(var i = 0; i < dt*this.particleCount*Rules.gameSpeed; i++) {
						if(Math.random()>0.1){
							new Electricity(this.sim, this.x+((Math.random()-0.5)*40), this.y+((Math.random()-0.5)*40)-50, 0, 0, 0)
						}
					}


				}
			}

 			class Mine extends Piece{
				constructor(sim, x, y){
					super("mine", sim, x, y)
					this.mass = 25;
					this.width = 30;
					this.height = 30;
					this.hitBoxRadius = 15;
					this.blowable = true;
					this.effect = {type: "damage", amount: 10};
				}
			}

			class Barricade extends Piece{
				constructor(sim, x, y){
					super("barricade", sim, x, y)
					this.width = 100;
					this.height = 100;
					this.hitBoxRadius = 45;
					this.blowable = false;
					this.effect = {type: "damage", amount: 10};
					this.surviveOutOfBounds = true;
				}
			}
			class Bouncer extends Piece{
				constructor(sim, x, y, bounceAmount){
					super("bouncer", sim, x, y)
					this.width = 120;
					this.height = 120;
					this.hitBoxSize = 100;
					this.bounceAmount = bounceAmount;
					this.blowable = false;
					this.effect = {type: "bounce"};
					this.surviveOutOfBounds = true;
				}
				tick(dt){
					this.effect = {type: "bounce", x: this.x, y: this.y, amount: this.bounceAmount};
				}
			}
			class Destructible extends Piece{
				constructor(sim, x, y){
					super("destructible", sim, x, y)
					this.width = 50;
					this.height = 50;
					this.hitBoxRadius = 25;
					this.health = 1;
					this.collider = true;
					this.blowable = false;
					this.effect = {type: "damage", amount: 10};
				}
			}
			class Turret extends Piece{
				constructor(sim, x, y, fireDelay, bulletSpeed, fireType, angleDeg, angleFixed){
					super("turret",sim, x, y)
					debug.expectNum(fireDelay, "fireDelay")
					debug.expectNum(bulletSpeed, "bulletSpeed")
					this.fireType = (fireType ? fireType : "bullet")
					this.angleFixed = angleFixed == "true" || angleFixed == true;
					this.angle = angleDeg;
					this.sim = sim;
					this.width = 100;
					this.height = 100;
					this.hitBoxRadius = 50;
					this.blowable = false;
					this.effect = {type: "damage", amount: 10};
					this.fireDelay = fireDelay;
					this.timeToNextFire = this.fireDelay;
					this.bulletSpeed = bulletSpeed;
				}
				tick(dt){
					this.particleTick(dt);
					let target = this.sim.reactor;
					if(target && !this.angleFixed){
						this.angle = calcAngle(this.x, this.y, target.x, target.y);
					}

					if(this.timeToNextFire <= 0){
						soundBank.play("shot");
						this.timeToNextFire = this.fireDelay;
						let velocity = this.bulletSpeed;
						let xVel = velocity*Math.cos(this.angle);
						let yVel = velocity*Math.sin(this.angle);
						this.sim.addPiece(this.x, this.y, this.fireType, {type: this.fireType, x: this.x, y: this.y, xVel: xVel, yVel: yVel})
					}else{
						this.timeToNextFire -= dt*Rules.gameSpeed;
					}
				}
				draw(context, camera){
					let pieceSpec = {
						piece: this,
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					context.draw(pieceSpec, Img.turret, camera, radToDeg(this.angle))
				}
			}
			class Bullet extends Piece{
				constructor(sim, x, y, xVel, yVel){
					super("bullet", sim, x, y)
					this.mass = 25;
					this.width = 26;
					this.height = 26;
					this.xVel = (xVel ? xVel : 0);
					this.yVel = (yVel ? yVel : 0);
					this.hitBoxRadius = 15;
					this.blowable = true;
					this.hasFriction = false;
					this.effect = {type: "damage", amount: 10};
				}
			}
			class PhaseBullet extends Bullet{
				constructor(sim, x, y, xVel, yVel){
					super(sim, x, y, xVel, yVel)
					this.type = "phaseBullet";
					this.width = 90;
					this.height = 45;
					this.hitBoxRadius = 15;
					this.blowable = false;
					this.hasFriction = false;
				}
			}
			class Text extends Piece{
				constructor(sim, x, y, text, condition){
					super("text", sim, x, y)
					debug.expect(text, "string", "text")
					this.hitBoxRadius = 10;
					this.text = text;
					this.condition = condition;
					this.blowable = false;
					this.effect = {type: "none"};
					this.surviveOutOfBounds = true;
				}
				draw(context, camera){
					let conditionMet = false;
					if(this.condition == "power" && this.sim.boundary.earthIsOn){
						conditionMet = true;
					}
					if((!this.condition || conditionMet) && !Rules.isCinematic){
						let drawX = this.x-(camera.x-canvasWidth/2);
						let drawY = this.y-(camera.y-canvasHeight/2);
						context.font = "30px Arial";
						context.fillStyle = 'white';
						context.fillText(this.text, drawX, drawY);
					}
				}
			}

 			class Blower extends Piece{
				constructor(sim, x, y, control){
					super("blower", sim, x, y)
					if(respawnCoords){
						this.x = respawnCoords.x;
						this.y = respawnCoords.y;
					}
					this.width = 50;
					this.height = 50;
					this.hitBoxRadius = 25;
					this.blowable = false;
					this.effect = {type: "none"};
					this.collider = false;
					this.surviveOutOfBounds = true;

					this.control = control;
					this.angle = (Math.random()*Math.PI*2)-Math.PI;
					this.speed = Rules.playerSpeed;
				}
				draw(context, camera){
					let pieceSpec = {
						piece: this,
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					let angle = (this.angle/Math.PI)*180
					context.draw(pieceSpec, Img.blower, camera, angle)
				}
				moveTick(dt){
					if(wDown){
						this.y -= this.speed*dt*Rules.gameSpeed;
					}
					if(sDown || this.credits){
						this.y += this.speed*dt*Rules.gameSpeed;
					}
					if(aDown || (this.credits && this.x > 0)){
						this.x -= this.speed*dt*Rules.gameSpeed;
					}
					if(dDown || (this.credits && this.x < 0)){
						this.x += this.speed*dt*Rules.gameSpeed;
					}
					[this.x,this.y] = this.sim.boundary.clamp(this.x,this.y);
				}
				particleTick(dt){
					if(Rules.gameSpeed){
						new Trail(this.sim, this.x+((Math.random()-0.5)*20), this.y+((Math.random()-0.5)*10), 0, 0, 0)
					}
					if(this.blowing){
						for (var i = 0; i < 100*dt*Rules.gameSpeed; i++) {
							let particleAngleMargin = degToRad(90)
							let particleAngle = this.angle+((Math.random()-0.5)*particleAngleMargin)
							let velocity = 750;
							let xVel = velocity*Math.cos(particleAngle);
							let yVel = velocity*Math.sin(particleAngle);
							new Force(
								this.sim, 
								this.x, 
								this.y, 
								xVel, 
								yVel, 
								radToDeg(particleAngle)+180, 
								this
							);
						}
					}
				}
				ai(pieceList){
					let directionList = ["up", "down", "left", "right"]
					
				}
				tick(dt){
					this.moveTick(dt);
					this.particleTick(dt)
					if(this.health <= 0 && !this.warping){
						this.dead = true;
					}
				}
				setTarget(x, y){
					this.angle = calcAngle(this.x, this.y, x, y);
				}
			}

			class Particle extends Piece{
				constructor(type, sim, x, y, xVel, yVel, angle=0, parent=null){
					super(type, sim, x, y, true)
					this.width = 5;
					this.height = 5;
					this.xVel = xVel;
					this.yVel = yVel;
					this.blowable = false;
					this.collider = false;
					this.lifeRemaining = Rules.blowRange/(xVel+yVel);
					this.angle = angle;
					if( parent ) {
						this.parent = parent;
						this.px = this.parent.x;
						this.py = this.parent.y;
					}
				}
				draw(context, camera){
					let pieceSpec = {
						piece: this,
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					context.draw(pieceSpec, Img[this.type], camera, this.angle)
				}
				tick(dt){
					if(!this.dead){
						if( this.parent ) {
							let pdx = this.parent.x - this.px;
							let pdy = this.parent.y - this.py;
							this.x += pdx;
							this.y += pdy;
							this.px = this.parent.x;
							this.py = this.parent.y;
						}

						this.applyVelocity(dt)

						this.lifeRemaining -= dt*Rules.gameSpeed;
						if(this.lifeRemaining <= 0){
							this.dead = true;
						}
					}
				}
			}
			class Force extends Particle{
				constructor(sim, x, y, xVel, yVel, angle, parent){
					super("force", sim, x, y, xVel, yVel, angle, parent)
					this.width = 40;
					this.height = 10;
					this.lifeRemaining = (Math.random()+0.5)*0.2;
				}
			}
			class Trail extends Particle{
				constructor(sim, x, y, xVel, yVel){
					super("trail", sim, x, y, xVel, yVel)
					this.width = 5;
					this.height = 5;
					this.angle = Math.random()*360;
					this.lifeRemaining = (Math.random()+0.5)*0.2;
				}
			}
			class Electricity extends Particle{
				constructor(sim, x, y, xVel, yVel){
					super("electricity", sim, x, y, xVel, yVel)
					this.width = 20;
					this.height = 20;
					this.angle = Math.random()*360;
					this.lifeRemaining = Math.random()*0.2;
				}
			}
			class PortalEnergy extends Particle{
				constructor(sim, x, y, xVel, yVel){
					super("portalEnergy", sim, x, y, xVel, yVel)
					this.width = 20;
					this.height = 20;
					this.angle = Math.random()*360;
					this.lifeRemaining = 0.5;
				}
			}
			class ExplosionGeneric extends Particle{
				constructor(type, sim, x, y, xVel, yVel, scale=1.0){
					super(type, sim, x, y, xVel, yVel)
					this.width = 200;					this.height = 200;
					this.angle = 0;
					this.totalLife = 0.52;
					this.lifeRemaining = this.totalLife;
					this.img = Img[this.type];
					this.scale = scale;
				}
				draw(context, camera){
					let frameCount = 13;
					let frame = Math.floor(((this.totalLife-this.lifeRemaining)/this.totalLife)*frameCount) //12 frames in the explosion image.
					let frameWidth = 2548/frameCount;
					let frameHeight = 190;

					let pieceSpec = {
						piece: this,
						sx: frame*frameWidth,
						sy: 0,
						sw: frameWidth,
						sh: frameHeight,
						x: this.x,
						y: this.y,
						width: this.width*this.scale,
						height: this.height*this.scale,
						xAnchor: 0.5,
						yAnchor: 0.5
					};

					context.draw(pieceSpec, this.img, camera)
				}
			}
			class Explosion extends ExplosionGeneric {
				constructor(sim, x, y, xVel, yVel, scale=1.0){
					super("explosion",sim,x,y,xVel,yVel,scale);
				}
			}
			class ExplosionBlue extends ExplosionGeneric{
				constructor(sim, x, y, xVel, yVel, scale=0.8){
					super("explosionBlue",sim,x,y,xVel,yVel,scale);
				}
			}
 			//CONTROL
 			let wDown;
 			let sDown;
			let aDown;
			let dDown;
			function initControls(sim){
				let blower = sim.blower;
				let mouseX = 0;
				let mouseY = 0;
				$( document ).on("mousemove.controls", null, function( event ) {
					mouseX = event.pageX+blower.x-canvasWidth/2;
					mouseY = event.pageY+blower.y-canvasHeight/2;
					blower.setTarget(mouseX, mouseY)
				});
				$( document ).on("mousedown.controls", null,function( event ) {
					if( event.which == 1 ) { // left click
						soundBank.stop("repulse");
						soundBank.playLoop("repulse");
						blower.blowing = true;
					}
				});
				$( document ).on("mouseup.controls", null, function( event ) {
					soundBank.stop("repulse");
					blower.blowing = false;
				});
				$( document ).on("keyup.controls", null, function( event ) {
					if( event.key == 'e' || event.key == 'E') {
						if(window.location.href.indexOf('localhost')>=0 && Rules.isEditing){
							sim.editor.open()
						}
					}
				});
				$( document ).on("keydown.controls", null, function( event ) {
					if(event.key == "w" || event.key == "W"){
						wDown = true;
					}
					if(event.key == "s" || event.key == "S"){
						sDown = true;
					}
					if(event.key == "a" || event.key == "A"){
						aDown = true;
					}
					if(event.key == "d" || event.key == "D"){
						dDown = true;
					}
					if(event.key == "Escape"){
						if(Rules.gameSpeed){
							PauseGame(sim.elapsedTime)
							console.log("pause")
						}else{
							UnpauseGame()
							console.log("unpause")
						}
					}
				});
				$( document ).on("keyup.controls", null, function( event ) {
					if(event.key == "w" || event.key == "W"){
						wDown = false;
					}
					if(event.key == "s" || event.key == "S"){
						sDown = false;
					}
					if(event.key == "a" || event.key == "A"){
						aDown = false;
					}
					if(event.key == "d" || event.key == "D"){
						dDown = false;
					}
					
				});

			}
 			//VIEW
 			let ImageURLs = {
				blower: 'images/mover.png',
				reactor: 'images/reactor.png',
				gate: 'images/gate.png',
				checkPointOn: 'images/checkPointOn.png',
				checkPointOff: 'images/checkPointOff.png',
				receptical: 'images/receptical.png',
				mine: 'images/mine.png',
				barricade: 'images/barricade.png',
				bouncer: 'images/bouncerNoGlowSharp.png',
				destructible: 'images/destructible.png',
				turret: 'images/turret.png',
				bullet: 'images/bullet.png',
				phaseBullet: 'images/phaseBullet.png',
				background: 'images/black.png',
				earthOff: 'images/earthOff.png',
				earthOn: 'images/earthOn.png',
				force: 'images/particles/force2.png',
				trail: 'images/particles/trail.png',
				electricity: 'images/particles/lightning.png',
				portalEnergy: 'images/particles/trail.png',
				explosion: 'images/explosion.png',
				explosionBlue: 'images/explosionBlue.png',
				star0: 'images/star0.png',
				star1: 'images/star1.png',
				star2: 'images/star2.png',
				star3: 'images/star3.png',
				star4: 'images/star4.png',
				//minimapBackground: 'images/minimapBackground.jpg',
			};
 			let Img = {};
 			class View{
				constructor(){
 				}
				
 				loadFiles(imageURLs, target, callbackFn){
					let imagesRequested = 0;
					let imagesLoaded = 0;

					soundBank = new SoundBank();
					soundBank.load("explosionBig","sound/explosionBig.mp3");
					soundBank.load("explosionSmall","sound/explosionSmall2.wav");
					soundBank.load("shot","sound/shot.wav", 0.5);
					soundBank.load("click","sound/click.mp3", 3);
					soundBank.load("checkPoint","sound/checkPoint.wav", 3);
					soundBank.load("charging","sound/charging.wav", 0.75);
					soundBank.load("turnOn","sound/turnOn.mp3", 4);
					soundBank.load("warpIn","sound/warpIn.wav", 3);
					soundBank.load("warpOut","sound/warpOut.wav", 5);
					soundBank.load("bounce","sound/bounce.mp3", 5);
					soundBank.load("woosh","sound/sunDiscThrowerImpact.wav");
					soundBank.loadLoop("repulse",{
						src: "sound/repulse.wav",
						loop: true,
						volume: Rules.volume*2,
						sprite: {
							main: [0, 10000, true]
						}
					});
					soundBank.loadLoop("menuMusic",{
						src: "sound/music/ThemeMusicElectro.wav",
						loop: true,
						volume: Rules.musicVolume*10,
						sprite: {
							main: [0, 100000, true]
						}
					});
					soundBank.loadLoop("gameMusic",{
						src: "sound/music/ThemeMusicArcade.wav",
						loop: true,
						volume: Rules.musicVolume,
						sprite: {
							main: [0, 100000, true]
						}
					});
					soundBank.loadLoop("victoryMusic",{
						src: "sound/music/ThemeHeroic.mp3",
						loop: true,
						volume: Rules.musicVolume*5,
						sprite: {
							main: [0, 100000, true]
						}
					});

					for(let key in imageURLs){
						let image = imageURLs[key];
						target[key] = new Image();
						target[key].onload = function(){
							imagesLoaded ++
						};
						target[key].src = image;
						imagesRequested ++;
					}
 					let handle = setInterval( () => {
						if( imagesLoaded >= imagesRequested ) {
							console.assert(imagesLoaded == imagesRequested)
							clearInterval(handle);
							callbackFn();
						}
					},1)
				}
 				myCanvas(canvasId, boundary, middleWare){
					var canvas = document.getElementById(canvasId);
					var context = canvas.getContext('2d');
					context.middleWare = middleWare;
					context.canvas.width = window.innerWidth;
					context.canvas.height = window.innerHeight;

					context.clear = function(camera){
						if( levelPlan.backgroundImg && levelPlan.backgroundImg.complete ) {
							let img = levelPlan.backgroundImg;
							let xPct = (camera.x - boundary.xMin) / (boundary.width + context.canvas.width);
							let yPct = (camera.y - boundary.yMin) / (boundary.height + context.canvas.height);
							let bx = img.width * 0.40 * xPct;
							let by = img.height * 0.40 * yPct;
							let bw = img.width * 0.60;
							let bh = img.height * 0.60;
							debug.expectNum(bx, "bx");
							debug.expectNum(by, "by");
							debug.expectNum(bw, "bw");
							debug.expectNum(bh, "bh");
							this.drawImage(img, bx, by, bw, bh, 0, 0, canvas.width, canvas.height);
						} else {
							let backgroundName = levelPlan.background ? (boundary.earthIsOn ? "earthOn" : "earthOff") : "background";
							let backgroundImg = Img[backgroundName];
							this.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);
						}

						for( let i=0 ; i<window.star.length ; ++i ) {
							let star = window.star[i];
							let sx = ((star.x-camera.x) * star.depth) % star.xSpan;
							let sy = ((star.y-camera.y) * star.depth) % star.ySpan;
							this.drawImage(star.img,sx,sy,star.img.width,star.img.height);
						}
					
					}.bind(context)
					context.draw = function(spec, imageObj, camera, degrees){
						let x = spec.x-(camera.x-canvasWidth/2);
						let y = spec.y-(camera.y-canvasHeight/2);
						x -= spec.width*spec.xAnchor;
						y -= spec.height*spec.yAnchor;
						
						let w = spec.width;
						let h = spec.height;

						if(degrees){
							this.save();
							this.translate(x+w/2, y+h/2);
							this.rotate(degrees*Math.PI/180.0);
							this.translate(-x-w/2, -y-h/2);
						}
						this.middleWare(this, spec.piece, x, y, w, h);
						if(spec.sx !== undefined){
							this.drawImage(imageObj, spec.sx, spec.sy, spec.sw, spec.sh, x, y, w, h);
						}else{
							this.drawImage(imageObj, x, y, w, h);
						}
						if(degrees){
							this.restore();
						}
					}.bind(context)
					context.drawHighlight = function(x, y, w, h){
						context.beginPath();
						context.lineWidth="6";
						context.strokeStyle="red";
						context.rect(x, y, w, h);
						context.stroke();
					}.bind(context)
					/*context.clearMinimap = function(spec, imageObj){
						this.drawImage(Img.background, 0, 0, 280, 260);
					}.bind(context)*/
					return context
				}
 				render(context, camera, pieceList, boundary){
					context.clear(camera);
 					pieceList.sort(function(a, b){return b.z - a.z});
 					for(let i = 0; i < pieceList.length; i++){
						
						if(!pieceList[i].dead){
							pieceList[i].draw(context, camera)
						}
					}
					boundary.draw(context, camera)
				}
			}
 			//ORGANIZATION
 			function getTimeTable(elapsedTime,andCounting) {
 				let time = timeReadable(elapsedTime); //this is to get just 1 decimal point of detail.
				let timeYou = Records.you[level] && Records.you[level].time ? timeReadable(Records.you[level].time) : ( andCounting ? '?.?' : timeReadable(elapsedTime) );
				let timeBest = Records.best[level] && Records.best[level].time ? timeReadable(Records.best[level].time) : '?.?';
				let userBest = Records.best[level] && Records.best[level].userName ? Records.best[level].userName : '';
				let s = ''+
					'<div>'+
					'<table class="timeTable ctrMargin"><tr><td>Current time:</td><td class="right">'+time+'</td><td>'+(andCounting?'and counting':'seconds')+'</td></tr>'+
					'<tr><td>Your best:</td><td class="right">'+timeYou+'</td><td>seconds</td></tr>'+
					'<tr><td>Record:</td><td class="right">'+timeBest+'</td><td> by '+userBest+'</td></tr>'+
					'</div>'
				;
				return s;
			}

			function displayTitleScreen(){
				$("#canvas").hide()
				$("#brief").hide()
				$("#overlayMenu").hide()
				$("#levelSelect").hide()
				$("#menus").show()
				$("#titleScreen").show()
			}
			function displayLevelSelect(progress){
				$("#gameOverScreen").hide()
				$("#titleScreen").hide()
				$("#levelSelect").show()
				$("#levelRoster").empty();

				for (let i = 0; i < LevelList.length; i++) {
					let levelDisable = (i>0 && progress[i] === undefined);
					let cls 	= levelDisable ? ' levelDisable' : '';
					let action 	= levelDisable ? '' : 'id="levelButton'+i+'" onClick="startGameMusic(); respawnCoords = null; storedTime = 0; GameStart('+i+');"';
					$("#levelRoster").append(
						'<button class="menuButton levelButton '+cls+'" '+action+'>'+(i+1)+'</button>'
					);
					if((i+1)%10 == 0){
						$("#levelRoster").append('<br>');
					}
				}
				$("#levelBuilder").toggle(Rules.showLevelBuilder);
			}
			function displayGameOverScreen(win, elapsedTime){
				$("#levelSelect").hide()
				$('#gameWin').hide();
				$('#gameLose').hide();
 				$('button').off(".gameOver");

				$('.buttonMainMenu').on( 'click.gameOver', null, () => {
					GameClear();
					startMenuMusic();
					displayTitleScreen();
				});
				$('.buttonPlayAgain').on( 'click.gameOver', null, () => {
					GameClear();
					GameStart(level)
				});
				$('.buttonNextLevel').on( 'click.gameOver', null, () => {
					GameClear();
					respawnCoords = null; storedTime = 0;
					GameStart(level+1);
				});

				if(win){
					progressSave( level, elapsedTime, function() {
						$('#gameWin').show();
						$('#gameSummaryWin').hide();
						$('#gameWin button').hide();
						$('#gameSaving').show();

						let time = timeReadable(elapsedTime); //this is to get just 1 decimal point of detail.
						let isPersonalBest = !Records.you[level] || !Records.you[level].time || elapsedTime < Records.you[level].time;

						progressGet( function() {
							recordsGet( function() {
								let isRecord = elapsedTime == Records.best[level].time;

								let notify = isRecord ? 'You set the World Record!!!' : (isPersonalBest ? 'A new Personal Best!' : '');
								if( notify ) {
									notify += '<div class="spacer"></div>';
								}

								$('#gameSummaryWin').html(
									'Level '+(level+1)+' completed in '+time+' seconds!<br />'+
									'<div class="spacer"></div>'+
									notify+
									getTimeTable(elapsedTime,false)
								);
								$('#gameSummaryWin').show();

								$('#gameSaving').hide();
								$('#gameWin button').show();
								let showNextLevel = (!Rules.isDemo || level+1 < Rules.demoLevelLimit);
								$(".buttonNextLevel").toggle(showNextLevel);
							});
						});
					});
				}else{
					$('#gameSummaryLose').html('Level '+(level+1)+' failed!');
					$('#gameLose').show();
				}
				$("#pauseMenu").hide()
				$("#gameOverScreen").show()
				$("#overlayMenu").show()
			}
			function displayBrief(){
				$("#titleScreen").hide()
				$("#brief").show()
			}
 			function GameOver(){
 				soundBank.stop("repulse");
 				$(document).off(".controls")
 			}
 			function GameClear(){
 				clearInterval(handleInterval);
 				handleInterval = null;
 				cancelAnimationFrame(handleView)
 				handleView = null;

			}
			function startGameMusic(){
				soundBank.stopAll();
				soundBank.playLoop("gameMusic");
			}
			function startMenuMusic(){
				soundBank.stopAll();
				soundBank.playLoop("menuMusic");
			}
			function PauseGame(elapsedTime){
				Rules.gameSpeed = 0;
				$("#restartLevelButton").off( '.restartLevel' );
				$("#restartLevelButton").on( 'click.restartLevel', null, ()=>{
					GameOver();
					GameClear();
					GameStart(level);
				});
				$("#pauseMenuText").html(
					'Level '+(level+1)+' paused.<br />'+
					'<div class="spacer"></div>'+
					getTimeTable(elapsedTime,true)
				);
				$("#gameOverScreen").hide();
				$("#pauseMenu").show();
				$("#overlayMenu").show()

			}
			function UnpauseGame(){
				Rules.gameSpeed = Rules.runningGameSpeed;
				$("#overlayMenu").hide()
			}

			function GameStart(forceLevel) {
				progressGet( function(progress) {
					var i = 0;
					while(progress[i] && progress[i].time < Rules.timeFailtimeFail && i < LevelList.length-1){
						i ++;
					}
					if( forceLevel !== undefined && forceLevel !== null ) {
						i = forceLevel;
					}
					recordsGet( function() {
						GameMain(i);
					});
				});
			}

 			function GameMain(newLevel){

 				function getLevelPlan(level) {
 					let levelPlan = LevelList[level];
 					levelPlan.boundaryMargin = Math.max( levelPlan.boundaryMargin!==undefined ? (levelPlan.boundaryMargin || 0) : Rules.defaultBoundaryMargin, Rules.minBoundaryMargin );
 					return levelPlan;
 				}

 				soundBank.play("warpIn")
				UnpauseGame()
				//level = prompt("Which level would you like to play?");
				wDown = false;
				sDown = false;
				aDown = false;
				dDown = false;

				$("#menus").hide()
				level = newLevel;
				console.log('Loading level plan',level);
				levelPlan = getLevelPlan(level);
				let view = new View();
				let sim = new Sim();
				let middleWare = function(context, piece, x, y, w, h){
					if(sim.editor.isSelected(piece)){
						context.drawHighlight(x, y, w, h);
					}
				}
				let context = view.myCanvas('canvas', sim.boundary, middleWare);
				initControls(sim);
				if( levelPlan.backgroundUrl ) {
					levelPlan.backgroundImg = new Image();
					levelPlan.backgroundImg.src = levelPlan.backgroundUrl;
				}

				function tickSim(){
					if( !sim.gameFailLatch && !sim.reactor && !Rules.isEditing){
						sim.gameFailLatch = true;
						setTimeout(() => {
							GameOver()
							displayGameOverScreen(false, sim.elapsedTime)
						},2000)
					}

					sim.timeSinceLastSim = 0;
					let dt = 1/FPS;
					let now = Date.now();
					if(sim.nowPrior === null){
						sim.timeSinceLastSim = dt;
					}else{
						sim.timeSinceLastSim += (now - sim.nowPrior)/1000;
					}
					sim.nowPrior = now;
					while(sim.timeSinceLastSim >= dt){
						if(sim.tick(dt) == "next level"){
							return "next level"
						}
						sim.timeSinceLastSim -= dt;
					}
				}
 				function tickView(){
 					let camera = {};
 					if(sim.blower){
						camera.x = sim.blower.x;
						camera.y = sim.blower.y;
 					}else{
 						camera.x = 0;
 						camera.y = 0;
 					}
 
					view.render(context, camera, sim.pieceList, sim.boundary);
				}

				$("#titleScreen").hide()

				let animDone = true;
				let avLatch = false;
				function animateView(){
					//console.log('animView');
					tickView()
					if(tickSim() == "next level" && !avLatch ){
						avLatch = true;
						setTimeout(
							()=>{
								soundBank.play("woosh")
								GameOver()
								displayGameOverScreen(true, sim.elapsedTime)
							}, 0
						)
					}
					//console.log('animView request');
					animDone = true;
				}
				//console.log('animView start');
 				animateView();
 				function silly() {
 					if( animDone ) {
 						animDone = false;
						handleView = requestAnimationFrame( animateView );
					}
				}
				handleInterval = setInterval( silly, 1 );

				$("#canvas").show()

			}
			function triggerWhenReady(buttonSelector, trigger){
				let handle = setInterval(()=>{
					let shown = $(buttonSelector).is(":visible")
					if(shown){
						$(buttonSelector).trigger(trigger);
						clearInterval(handle);
					}
				}, 1)
			}

			function checkEditing(){
				if(!Rules.isEditing){return}
				triggerWhenReady("#levelSelectButton", "click")
				triggerWhenReady("#levelButton"+(Rules.startLevel-1), "click")
				var press = jQuery.Event("keyup");
				press.ctrlKey = false;
				press.key = "e";
				triggerWhenReady("#canvas", press);
			}

			function onResize() {
				let canvasId = "canvas"
				let canvas = document.getElementById(canvasId);
				if( !canvas ) return;
				let context = canvas.getContext('2d');
				if( !context ) return;
				context.canvas.width = window.innerWidth;
				context.canvas.height = window.innerHeight;
 				canvasWidth = context.canvas.width;
				canvasHeight = context.canvas.height;
				console.assert(canvasWidth > 0)
				console.assert(canvasHeight > 0)
				MakeStars(context);
			}

			$(document).ready(function(){
				if(Rules.isCinematic){
					document.getElementById("canvas").style.cursor = "none";
				}

				let view = new View();
				$('#loading').show();
				$('#titleButtons').hide();
				view.loadFiles(ImageURLs, Img, function() {
					recordsGet( function() {
						$('#loading').hide();
						$('#titleButtons').show();
						startMenuMusic()
						displayTitleScreen();
						checkEditing();
					});
				});
				onResize();
				
				$(window).resize( onResize );
				setInterval( function() {
					$('#demoNote').toggle(Rules.isDemo);
				}, 5*1000);
			});
			
	</script>
  </body>
</html>		
		</script>
	</head>
	<body>
		<div id="demoNote" class="hide"><div>DEMO</div></div>
		<div id="menus" class="ctr">
			<div id="menuBg">
				<img src='images/monitor.jpg'>
			</div>
			<div id="titleScreen" class="menu">
				<h1 class="menuTitle">
					Reactor Rescue
				</h1>
				<div class='spacer2x'></div>
				<div id="loading">Loading...</div>
				<div id="titleButtons">
					<button class="bigMenuButton" onClick="startGameMusic(); GameStart();">
						Play
					</button>
					<div class='spacer2x'></div>
					<button class="menuButton" onClick="displayBrief()">
						Briefing
					</button>
					<div class='spacer'></div>
					<button id="levelSelectButton" class="menuButton" onClick="progressGet(displayLevelSelect);">
						Level Select
					</button>
				</div>
			</div>
			<div id="brief" class="menu hide">
				<h1 class="menuTitle">
					Your Mission
				</h1>
				<div class="menuText">
					<p>
						The enemy has stolen the Quantum Arc-Reactor and placed it deep behind enemy lines!
						You must return it to High Command.
					</p>
					<p>
						WARNING: The Arc-Reactor is unstable!
						If it touches anything, it will go critical and Earth's most valuable asset will be destroyed.
					</p>
					<p>
						We can warp you in.
						Use your repulser to push the Arc-Reactor through the blue warp gates.
					</p>
					<p>
						Good Luck, Captain.
					</p>
				</div>
				<button class="menuButton" onClick="displayTitleScreen()">
					Understood
				</button>
			</div>
			<div id="levelSelect" class="menu hide">
				<h1 class="menuTitle">
					Choose A Level
				</h1>
				<div class="spacer"></div>
				<div id="levelRoster">
				</div>
				<div class="spacer"></div>
				<button class="menuButton" onClick="displayTitleScreen()">Back</button>
			</div>
		</div>
		<div id="canvasDiv" width="100%" height="100%">
			<div id="overlayMenu">
				<div id="pauseMenu">
					<h1 class="menuTitle pauseMenuTitle">
						Game Paused
					</h1>
					<div id="pauseMenuText" class="menuText ctr"></div>
					<div class="spacer"></div>
					<div class="ctr">
						<button class="menuButton" onclick="UnpauseGame()">
							Resume Game
						</button>
						<button class="menuButton" id="restartLevelButton">
							Restart Level
						</button>
						<button class="menuButton" onclick="GameOver(); GameClear(); startMenuMusic(); displayTitleScreen();">
							Main Menu
						</button>
					</div>
				</div>
				<div id="gameOverScreen" class="menu hide">
					<div id="gameWin">
						<h1 class="menuTitle ctr">Level Complete!</h1>
						<div class="spacer"></div>
						<div id="gameSummaryWin" class="menuText ctr"></div>
						<div class="spacer"></div>
						<div id='gameSaving' class="ctr">
							Saving...
						</div>
						<div class="ctr">
							<button class="buttonMainMenu menuButton">Main Menu</button>
							<button class="buttonPlayAgain menuButton">Play Again</button>
							<button class="buttonNextLevel menuButton">Next Level</button>
						</div>
					</div>
					<div id="gameLose">
						<h1 class="menuTitle ctr">Reactor Destroyed!</h1>
						<div class="spacer"></div>
						<div id="gameSummaryLose" class="menuText ctr"></div>
						<div class="spacer"></div>
						<div class="ctr">
							<button class="buttonMainMenu menuButton">Main Menu</button>
							<button class="buttonPlayAgain menuButton">Try Again</button>
						</div>
					</div>
				</div>

			</div>
			<canvas id="canvas" width="100%" height="100%"></canvas>
			<div id="editorPanel">
				<div> Placing type: <span id="placingType"></span></div>
				<div id="attributeBoxes"></div>
				<button id="showDataButton">Save</button>
				<button id="hideDataButton">Hide Data</button>
				<div id="levelData"></div>
			</div>
		</div>
	</body>
</html>
